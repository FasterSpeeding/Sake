{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sake","text":"<p>A distributed asynchronous cache interface (plus several implementations) designed for use with Hikari.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install Sake from PyPI using the following command.</p> <pre><code>python -m pip install hikari-sake -U\n</code></pre> <p>The <code>hikari-sake[tanjun]</code> feature flag can be used to ensure that the installed Tanjun version is compatible with Sake's Tanjun adapters. You should still have a Tanjun version pinned in your own requirements as this just provides an acceptable range for the requirement.</p>"},{"location":"#support","title":"Support","text":"<p>Hikari's support guild provides for support for Sake.</p>"},{"location":"#quick-usage","title":"Quick Usage.","text":"<p>For usage see the the documentation and examples .</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#107","title":"1.0.7","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fix hikari.errors.UnrecognisedEntityError handling in the Redis iterators.   This will no-longer lead to an NameError being raised.</li> </ul>"},{"location":"changelog/#106","title":"1.0.6","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Catch and ignore hikari.errors.UnrecognisedEntityError during iteration.</li> </ul>"},{"location":"changelog/#105a1","title":"1.0.5a1","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li><code>\"tanjun\"</code> feature flag for ensuring this is installed with a Tanjun version that's   compatible with the Tanjun adapters.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Dropped support for Python 3.8.</li> </ul>"},{"location":"changelog/#104a1post1-2022-11-10","title":"1.0.4a1.post1 - 2022-11-10","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Switched from aioredis to redis-py for connecting to Redis to properly support   Python 3.11.</li> </ul>"},{"location":"changelog/#104a1-2022-11-10","title":"1.0.4a1 - 2022-11-10","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Bumped the minimum hikari version to 2.0.0.dev112.</li> <li>Avoid fetching the bot's user to get it's ID if a READY event has already   been received.</li> <li>The Tanjun adapter get and iter methods no-longer raise TypeError when   the inner-client is inactive.</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Async locking when fetching the bot's ID internally and ensure it only   fetches once.</li> <li>Raise sake.errors.ClosedClient instead of TypeError when the Sake   Client is inactive (from get and iter methods).</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>The project metadata dunder attributes from sake.   importlib.metadata should be used to get this metadata instead.</li> <li><code>sake.redis_iterators</code> is now internal/hidden.</li> <li><code>redis.ResourceClient.get_connection</code> is now internal/hidden.</li> </ul>"},{"location":"changelog/#103a1post1-2022-08-30","title":"1.0.3a1.post1 - 2022-08-30","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Bumped the minimum hikari version to 2.0.0.dev110.</li> </ul>"},{"location":"changelog/#103a1-2022-08-27","title":"1.0.3a1 - 2022-08-27","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Fixed compatibility with newer Hikari and Tanjun releases.</li> </ul>"},{"location":"changelog/#102a1-2022-01-13","title":"1.0.2a1 - 2022-01-13","text":""},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>The Redis <code>clear_voice_states_for_guild</code> method mishandling passing coroutines to   <code>asyncio.gather</code> leading to errors being raised.</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>The Prefix and Integration cache implementations and interfaces as a part of   pruning out-of-scope and useless cache stores.</li> </ul>"},{"location":"changelog/#101a1-2022-01-06","title":"1.0.1a1 - 2022-01-06","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li><code>RedisResource.add_to_tanjun</code> method for easier integration with Tanjun.   This both registers dependencies for the resource abcs and impls but also   registers adapters which make Sake compatible with Tanjun's AsyncCache   interfaces for the relevant resources.</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li><code>abc.ABC</code> is now used as the base class for the abstract interfaces in   <code>sake.abc</code> instead of <code>typing.Protocol</code>.</li> <li><code>abc.CacheIterator.len</code> is now guaranteed to always returns <code>int</code>.</li> </ul>"},{"location":"changelog/#100a1-2021-12-25","title":"1.0.0a1 - 2021-12-25","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Python 3.10 compatibility thx to Aioredis 2.0.0.</li> <li>Efficiency improvements brought in by the switch to listening to raw   event dispatch.</li> <li><code>ClosedClient</code> error which is raised in favour of <code>RuntimeError</code> when   an operation is attempted on an inactive sake client.</li> <li>Client <code>is_alive</code> attribute (both on the abstract interface and redit impl).</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Aioredis dependency minimum version to 2.0.0   This comes with breaking changes to how RedisClient is initialised as   parameters have been replaced and changed (semantically speaking).   For more information on this see the documentation.   And the client returned by <code>RedisClient.get_connection</code> is now   fundamentally different.</li> <li>Bumped Hikari dependency minimum version to 2.0.0.dev104.</li> <li>The structure and semantics of internal aspects of RedisClient like how   it manages the database connections and how it loads listeners have changed.</li> <li>Renamed <code>sake.traits</code> to <code>sake.abc</code>.</li> <li>Renamed <code>RedisClient.rest</code> to <code>app</code> and <code>.dispatch</code> to <code>.event_manager</code>.</li> <li>IDs are now always stored as strings.</li> <li>Renamed <code>rest</code> to <code>app</code> in <code>RedisClient.__init__</code> and moved away from inferring   the event manager from this argument (it now must always be passed as   <code>event_manager</code> if you want the client to listen to events to fill itself).</li> <li><code>event_managed</code> argument to <code>RedisClient.__init__</code> to let the client be started   based on the linked event manager.</li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li><code>sake.marshalling</code> and any relevant properties and arguments.</li> <li>The utility functions in <code>sake.redis_iterators</code> are now private.</li> <li>The \"set\" methods have been removed from the abstract interfaces in <code>sake.abc</code>   as these are now considered implementation detail.</li> <li>While this wasn't ever officially supported, passing <code>hikari.Unique</code> objects in   place of IDs to RedisClients will now lead to erroneous behaviour due to an   internal refactor in how IDs are handled.</li> <li><code>window_size</code> parameter from <code>RedisClient.clear_*</code> methods as these are no-longer   chunked.</li> </ul>"},{"location":"usage/","title":"Usage","text":"<p>Coming soon.</p>"},{"location":"reference/","title":"sake","text":"<p>A distributed asynchronous cache standard designed for Hikari.</p> <p>For the interfaces defined by this standard see sake.abc.</p> <p>For standard implementation(s) see:</p> <ul> <li>Redis: sake.redis</li> </ul>"},{"location":"reference/#sake.BackendError","title":"BackendError","text":"<p>         Bases: <code>SakeException</code>, <code>ValueError</code></p> <p>Error that's raised when communicating with the backend fails.</p> <p>This may be a sign of underlying network or database issues.</p>"},{"location":"reference/#sake.CannotDelete","title":"CannotDelete","text":"<p>         Bases: <code>SakeException</code>, <code>ValueError</code></p> <p>Error that's raised in response to an attempt to delete an entry which can't be deleted.</p> <p>This most likely reason for this to be raised would be due to an attempt to deleted a entry that's being kept alive by references without specifying to cascade references in a referential database.</p>"},{"location":"reference/#sake.ClosedClient","title":"ClosedClient","text":"<p>         Bases: <code>SakeException</code></p> <p>Error that's raised when an attempt to use an inactive client is made.</p>"},{"location":"reference/#sake.EntryNotFound","title":"EntryNotFound","text":"<p>         Bases: <code>SakeException</code>, <code>LookupError</code></p> <p>Error that's raised in response to an attempt to get an entry which doesn't exist.</p> <p>Note</p> <p>This shouldn't ever be raised by a delete method or iter method.</p>"},{"location":"reference/#sake.InvalidDataFound","title":"InvalidDataFound","text":"<p>         Bases: <code>SakeException</code>, <code>LookupError</code></p> <p>Error that's raised when the retrieved data is in an unexpected format.</p> <p>This may indicate that you are running different versions of a Sake implementation with the same database.</p>"},{"location":"reference/#sake.RedisCache","title":"RedisCache","text":"<p>         Bases: <code>GuildCache</code>, <code>EmojiCache</code>, <code>GuildChannelCache</code>, <code>InviteCache</code>, <code>MemberCache</code>, <code>MessageCache</code>, <code>PresenceCache</code>, <code>RoleCache</code>, <code>UserCache</code>, <code>VoiceStateCache</code>, <code>sake_abc.Cache</code></p> <p>A Redis implementation of all the defined cache resources.</p>"},{"location":"reference/#sake.SakeException","title":"SakeException","text":"<p>         Bases: <code>Exception</code></p> <p>Base exception for the expected exceptions raised by Sake implementations.</p>"},{"location":"reference/#sake.errors.SakeException.base","title":"base  <code>class-attribute</code>","text":"<pre><code>base: typing.Optional[Exception]\n</code></pre> <p>The exception which caused this exception if applicable else None.</p>"},{"location":"reference/#sake.errors.SakeException.__init__","title":"__init__","text":"<pre><code>__init__(message, *, exception=None)\n</code></pre> <p>Initialise a sake exception instance.</p> PARAMETER DESCRIPTION <code>message</code> <p>The exception's message.</p> <p> TYPE: <code>str</code> </p> <code>exception</code> <p>The exception which caused this exception if applicable else None.</p> <p> TYPE: <code>typing.Optional[Exception]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/abc/","title":"sake.abc","text":"<p>Protocols and abstract classes for the cache resources defined by this standard.</p> <p>Note</p> <p>Unlike the abstract classes defined here, there is no guarantee that the protocols defined here will be included in the MRO of the classes which implement them.</p>"},{"location":"reference/abc/#sake.abc.Cache","title":"Cache","text":"<p>         Bases: <code>GuildCache</code>, <code>EmojiCache</code>, <code>GuildChannelCache</code>, <code>InviteCache</code>, <code>MeCache</code>, <code>MemberCache</code>, <code>MessageCache</code>, <code>PresenceCache</code>, <code>RoleCache</code>, <code>UserCache</code>, <code>VoiceStateCache</code>, <code>abc.ABC</code></p> <p>Protocol of a cache which implements all the defined resources.</p>"},{"location":"reference/abc/#sake.abc.CacheIterator","title":"CacheIterator","text":"<p>         Bases: <code>hikari.LazyIterator[_T]</code>, <code>abc.ABC</code></p> <p>A asynchronous iterator of entries within a defined cache store.</p>"},{"location":"reference/abc/#sake.abc.CacheIterator.len","title":"len  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>len()\n</code></pre> <p>Get the count of entries that this iterator covers.</p> <p>Note</p> <p>Unlike hikari.iterators.LazyIterator.count, this will not exhaust the iterator and may return different values as entries are added and removed from the cache.</p> RETURNS DESCRIPTION <code>int</code> <p>The count of entries that this iterator covers as of the call.</p>"},{"location":"reference/abc/#sake.abc.EmojiCache","title":"EmojiCache","text":"<p>         Bases: <code>Resource</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a emoji cache.</p>"},{"location":"reference/abc/#sake.abc.EmojiCache.clear_emojis","title":"clear_emojis  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_emojis()\n</code></pre> <p>Empty the emoji cache store.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.EmojiCache.delete_emoji","title":"delete_emoji  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_emoji(emoji_id)\n</code></pre> <p>Remove an emoji from the cache.</p> <p>Note</p> <p>Delete methods do not raise sake.errors.EntryNotFound when the targeted entity doesn't exist.</p> PARAMETER DESCRIPTION <code>emoji_id</code> <p>The ID of the emoji to remove from the cache.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.EmojiCache.get_emoji","title":"get_emoji  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_emoji(emoji_id)\n</code></pre> <p>Get an emoji from the cache.</p> PARAMETER DESCRIPTION <code>emoji_id</code> <p>The ID of the emoji to get from the cache.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>hikari.emojis.KnownCustomEmoji</code> <p>The object of the emoji fetched from the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.EntryNotFound</code> <p>Raised when the targeted entity wasn't found.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.EmojiCache.iter_emojis","title":"iter_emojis  <code>abstractmethod</code>","text":"<pre><code>iter_emojis()\n</code></pre> <p>Iterate over the emojis stored in the cache.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> RETURNS DESCRIPTION <code>CacheIterator[hikari.emojis.KnownCustomEmoji]</code> <p>An async iterator of the emojis stored in the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.GuildCache","title":"GuildCache","text":"<p>         Bases: <code>Resource</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a guild cache.</p>"},{"location":"reference/abc/#sake.abc.GuildCache.clear_guilds","title":"clear_guilds  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_guilds()\n</code></pre> <p>Empty the guild cache store.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.GuildCache.delete_guild","title":"delete_guild  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_guild(guild_id)\n</code></pre> <p>Remove a guild from the cache.</p> <p>Note</p> <p>Delete methods do not raise sake.errors.EntryNotFound when the targeted entity doesn't exist.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to remove from the cache.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.GuildCache.get_guild","title":"get_guild  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_guild(guild_id)\n</code></pre> <p>Get a guild from the cache.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to get from the cache.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>hikari.guilds.GatewayGuild</code> <p>The object of the guild fetched from the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.EntryNotFound</code> <p>Raised when the targeted entity wasn't found.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.GuildCache.iter_guilds","title":"iter_guilds  <code>abstractmethod</code>","text":"<pre><code>iter_guilds()\n</code></pre> <p>Iterate over the guilds stored in the cache.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> RETURNS DESCRIPTION <code>CacheIterator[hikari.guilds.GatewayGuild]</code> <p>An async iterator of the guilds stored in the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.GuildChannelCache","title":"GuildChannelCache","text":"<p>         Bases: <code>Resource</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a guild channel cache.</p>"},{"location":"reference/abc/#sake.abc.GuildChannelCache.clear_guild_channels","title":"clear_guild_channels  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_guild_channels()\n</code></pre> <p>Empty the guild channel cache store.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.GuildChannelCache.delete_guild_channel","title":"delete_guild_channel  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_guild_channel(channel_id)\n</code></pre> <p>Remove a guild guild channel from the cache.</p> <p>Note</p> <p>Delete methods do not raise sake.errors.EntryNotFound when the targeted entity doesn't exist.</p> PARAMETER DESCRIPTION <code>channel_id</code> <p>The ID of the guild channel to remove from the cache.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.GuildChannelCache.get_guild_channel","title":"get_guild_channel  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_guild_channel(channel_id)\n</code></pre> <p>Get a guild channel from the cache.</p> PARAMETER DESCRIPTION <code>channel_id</code> <p>The ID of the guild channel to get from the cache.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>hikari.channels.PermissibleGuildChannel</code> <p>The object of the guild channel fetched from the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.EntryNotFound</code> <p>Raised when the targeted entity wasn't found.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.GuildChannelCache.iter_guild_channels","title":"iter_guild_channels  <code>abstractmethod</code>","text":"<pre><code>iter_guild_channels()\n</code></pre> <p>Iterate over the guild channels stored in the cache.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> RETURNS DESCRIPTION <code>CacheIterator[hikari.channels.PermissibleGuildChannel]</code> <p>An async iterator of the guild channels stored in the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.InviteCache","title":"InviteCache","text":"<p>         Bases: <code>Resource</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a invite cache.</p>"},{"location":"reference/abc/#sake.abc.InviteCache.clear_invites","title":"clear_invites  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_invites()\n</code></pre> <p>Empty the invites cache store.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.InviteCache.delete_invite","title":"delete_invite  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_invite(invite_code)\n</code></pre> <p>Remove an invite channel from the cache.</p> <p>Note</p> <p>Delete methods do not raise sake.errors.EntryNotFound when the targeted entity doesn't exist.</p> PARAMETER DESCRIPTION <code>invite_code</code> <p>The code of the invite to remove from the cache.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.InviteCache.get_invite","title":"get_invite  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_invite(invite_code)\n</code></pre> <p>Get an invite from the cache.</p> PARAMETER DESCRIPTION <code>invite_code</code> <p>The code of the invite to get from the cache.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>hikari.invites.InviteWithMetadata</code> <p>The object of the invite fetched from the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.EntryNotFound</code> <p>Raised when the targeted entity wasn't found.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.InviteCache.iter_invites","title":"iter_invites  <code>abstractmethod</code>","text":"<pre><code>iter_invites()\n</code></pre> <p>Iterate over the invites stored in the cache.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> RETURNS DESCRIPTION <code>CacheIterator[hikari.invites.InviteWithMetadata]</code> <p>An async iterator of the invites stored in the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.MeCache","title":"MeCache","text":"<p>         Bases: <code>Resource</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a own user cache.</p>"},{"location":"reference/abc/#sake.abc.MeCache.delete_me","title":"delete_me  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_me()\n</code></pre> <p>Remove the cached own user entry.</p> <p>Note</p> <p>Delete methods do not raise sake.errors.EntryNotFound when the targeted entity doesn't exist.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.MeCache.get_me","title":"get_me  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_me()\n</code></pre> <p>Get the own user cache entry.</p> RETURNS DESCRIPTION <code>hikari.users.OwnUser</code> <p>The object of the own user fetched from the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.EntryNotFound</code> <p>Raised when the targeted entity wasn't found.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.MemberCache","title":"MemberCache","text":"<p>         Bases: <code>Resource</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a member cache.</p>"},{"location":"reference/abc/#sake.abc.MemberCache.clear_members","title":"clear_members  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_members()\n</code></pre> <p>Empty the members cache store.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.MemberCache.delete_member","title":"delete_member  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_member(guild_id, user_id)\n</code></pre> <p>Remove a member from the cache.</p> <p>Note</p> <p>Delete methods do not raise sake.errors.EntryNotFound when the targeted entity doesn't exist.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to remove a cached member for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> <code>user_id</code> <p>The ID of the user to remove a cached member for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.MemberCache.get_member","title":"get_member  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_member(guild_id, user_id)\n</code></pre> <p>Get a member from the cache.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to get a cached member for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> <code>user_id</code> <p>The ID of the user to get a cached member for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>hikari.guilds.Member</code> <p>The object of the member fetched from the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.EntryNotFound</code> <p>Raised when the targeted entity wasn't found.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.MemberCache.iter_members","title":"iter_members  <code>abstractmethod</code>","text":"<pre><code>iter_members()\n</code></pre> <p>Iterate over the members stored in the cache.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> RETURNS DESCRIPTION <code>CacheIterator[hikari.guilds.Member]</code> <p>An async iterator of the members stored in the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.MessageCache","title":"MessageCache","text":"<p>         Bases: <code>Resource</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a message cache.</p>"},{"location":"reference/abc/#sake.abc.MessageCache.clear_messages","title":"clear_messages  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_messages()\n</code></pre> <p>Empty the messages cache store.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.MessageCache.delete_message","title":"delete_message  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_message(message_id)\n</code></pre> <p>Remove a message from the cache.</p> <p>Note</p> <p>Delete methods do not raise sake.errors.EntryNotFound when the targeted entity doesn't exist.</p> PARAMETER DESCRIPTION <code>message_id</code> <p>The ID of the message to remove from the cache.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.MessageCache.get_message","title":"get_message  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_message(message_id)\n</code></pre> <p>Get a message from the cache.</p> PARAMETER DESCRIPTION <code>message_id</code> <p>The ID of the message to get from the cache.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>hikari.messages.Message</code> <p>The object of the message fetched from the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.EntryNotFound</code> <p>Raised when the targeted entity wasn't found.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.MessageCache.iter_messages","title":"iter_messages  <code>abstractmethod</code>","text":"<pre><code>iter_messages()\n</code></pre> <p>Iterate over the messages stored in the cache.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> RETURNS DESCRIPTION <code>CacheIterator[hikari.messages.Message]</code> <p>An async iterator of the messages stored in the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.PresenceCache","title":"PresenceCache","text":"<p>         Bases: <code>Resource</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a presence cache.</p>"},{"location":"reference/abc/#sake.abc.PresenceCache.clear_presences","title":"clear_presences  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_presences()\n</code></pre> <p>Empty the presences cache store.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.PresenceCache.delete_presence","title":"delete_presence  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_presence(guild_id, user_id)\n</code></pre> <p>Remove a presence from the cache.</p> <p>Note</p> <p>Delete methods do not raise sake.errors.EntryNotFound when the targeted entity doesn't exist.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to remove a cached presence for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> <code>user_id</code> <p>The ID of the user to remove a cached presence for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.PresenceCache.get_presence","title":"get_presence  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_presence(guild_id, user_id)\n</code></pre> <p>Get a presence from the cache.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to get a cached presence for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> <code>user_id</code> <p>The ID of the user to get a cached presence for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>hikari.presences.MemberPresence</code> <p>The object of the presence fetched from the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.EntryNotFound</code> <p>Raised when the targeted entity wasn't found.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.PresenceCache.iter_presences","title":"iter_presences  <code>abstractmethod</code>","text":"<pre><code>iter_presences()\n</code></pre> <p>Iterate over the presences stored in the cache.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> RETURNS DESCRIPTION <code>CacheIterator[hikari.presences.MemberPresence]</code> <p>An async iterator of the presences stored in the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.RefCache","title":"RefCache","text":"<p>         Bases: <code>Cache</code>, <code>RefGuildCache</code>, <code>RefEmojiCache</code>, <code>RefGuildChannelCache</code>, <code>RefInviteCache</code>, <code>RefMeCache</code>, <code>RefMemberCache</code>, <code>RefMessageCache</code>, <code>RefPresenceCache</code>, <code>RefRoleCache</code>, <code>RefUserCache</code>, <code>RefVoiceStateCache</code>, <code>abc.ABC</code></p> <p>Protocol of a cache which implements all the defined reference resources.</p>"},{"location":"reference/abc/#sake.abc.RefEmojiCache","title":"RefEmojiCache","text":"<p>         Bases: <code>EmojiCache</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a referential emoji cache.</p>"},{"location":"reference/abc/#sake.abc.RefEmojiCache.clear_emojis_for_guild","title":"clear_emojis_for_guild  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_emojis_for_guild(guild_id)\n</code></pre> <p>Remove emojis belonging to a specific guild from the cache.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to remove the emojis cached for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.RefEmojiCache.iter_emojis_for_guild","title":"iter_emojis_for_guild  <code>abstractmethod</code>","text":"<pre><code>iter_emojis_for_guild(guild_id)\n</code></pre> <p>Iterate over the emojis stored in the cache for a specific guild.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to iterate over the emojis cached for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>CacheIterator[hikari.emojis.KnownCustomEmoji]</code> <p>An async iterator of the emojis stored in the cache for the specified guild.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.RefGuildChannelCache","title":"RefGuildChannelCache","text":"<p>         Bases: <code>GuildChannelCache</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a referential guild channel cache.</p>"},{"location":"reference/abc/#sake.abc.RefGuildChannelCache.clear_guild_channels_for_guild","title":"clear_guild_channels_for_guild  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_guild_channels_for_guild(guild_id)\n</code></pre> <p>Remove the guild channel cache store for the specified guild.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to remove the cached channels for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.RefGuildChannelCache.iter_guild_channels_for_guild","title":"iter_guild_channels_for_guild  <code>abstractmethod</code>","text":"<pre><code>iter_guild_channels_for_guild(guild_id)\n</code></pre> <p>Iterate over the guild channels stored in the cache for a specific guild.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to iterate over the guild channels cached for it.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>CacheIterator[hikari.channels.PermissibleGuildChannel]</code> <p>An async iterator of the guild channels stored in the cache for the specified guild.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.RefInviteCache","title":"RefInviteCache","text":"<p>         Bases: <code>InviteCache</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a referential invite cache.</p>"},{"location":"reference/abc/#sake.abc.RefInviteCache.clear_invites_for_channel","title":"clear_invites_for_channel  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_invites_for_channel(channel_id)\n</code></pre> <p>Remove invites cached for a specific channel..</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> PARAMETER DESCRIPTION <code>channel_id</code> <p>The ID of the channel to remove the invites cached for it.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.RefInviteCache.clear_invites_for_guild","title":"clear_invites_for_guild  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_invites_for_guild(guild_id)\n</code></pre> <p>Remove invites cached for a specific guild.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to remove the invites cached for it.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.RefInviteCache.iter_invites_for_channel","title":"iter_invites_for_channel  <code>abstractmethod</code>","text":"<pre><code>iter_invites_for_channel(channel_id)\n</code></pre> <p>Iterate over the invites stored in the cache for a specific channel.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> PARAMETER DESCRIPTION <code>channel_id</code> <p>The ID of the channel to iterate over the invites cached for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>CacheIterator[hikari.invites.InviteWithMetadata]</code> <p>An async iterator of the invites stored in the cache for the specified channel.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.RefInviteCache.iter_invites_for_guild","title":"iter_invites_for_guild  <code>abstractmethod</code>","text":"<pre><code>iter_invites_for_guild(guild_id)\n</code></pre> <p>Iterate over the invites stored in the cache for a specific guild.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to iterate over the invites cached for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>CacheIterator[hikari.invites.InviteWithMetadata]</code> <p>An async iterator of the invites stored in the cache for the specified guild.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.RefMemberCache","title":"RefMemberCache","text":"<p>         Bases: <code>MemberCache</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a referential member cache.</p>"},{"location":"reference/abc/#sake.abc.RefMemberCache.clear_members_for_guild","title":"clear_members_for_guild  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_members_for_guild(guild_id)\n</code></pre> <p>Remove the members cached for a specific guild.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to remove the cached members for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.RefMemberCache.clear_members_for_user","title":"clear_members_for_user  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_members_for_user(user_id)\n</code></pre> <p>Remove the members cached for a specific user.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> PARAMETER DESCRIPTION <code>user_id</code> <p>The ID of the user to remove the cached members for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.RefMemberCache.iter_members_for_guild","title":"iter_members_for_guild  <code>abstractmethod</code>","text":"<pre><code>iter_members_for_guild(guild_id)\n</code></pre> <p>Iterate over the members stored in the cache for a specific guild.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to get the members cached for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>CacheIterator[hikari.guilds.Member]</code> <p>An async iterator of the members stored in the cache for the specified guild.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.RefMemberCache.iter_members_for_user","title":"iter_members_for_user  <code>abstractmethod</code>","text":"<pre><code>iter_members_for_user(user_id)\n</code></pre> <p>Iterate over the members stored in the cache for a specific user.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> PARAMETER DESCRIPTION <code>user_id</code> <p>The ID of the guild to get the user cached for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>CacheIterator[hikari.guilds.Member]</code> <p>An async iterator of the members stored in the cache for the specified user.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.RefMessageCache","title":"RefMessageCache","text":"<p>         Bases: <code>MessageCache</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a referential message cache.</p>"},{"location":"reference/abc/#sake.abc.RefMessageCache.clear_messages_for_author","title":"clear_messages_for_author  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_messages_for_author(user_id)\n</code></pre> <p>Remove the messages cached for a specific author.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> PARAMETER DESCRIPTION <code>user_id</code> <p>The ID of the user to remove the messages cached for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.RefMessageCache.clear_messages_for_channel","title":"clear_messages_for_channel  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_messages_for_channel(channel_id)\n</code></pre> <p>Remove the messages cached for a specific channel.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> PARAMETER DESCRIPTION <code>channel_id</code> <p>The ID of the channel to remove the messages cached for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.RefMessageCache.clear_messages_for_guild","title":"clear_messages_for_guild  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_messages_for_guild(guild_id)\n</code></pre> <p>Remove the messages cached for a specific guild.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to remove the messages cached for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.RefMessageCache.iter_message_for_channel","title":"iter_message_for_channel  <code>abstractmethod</code>","text":"<pre><code>iter_message_for_channel(channel_id)\n</code></pre> <p>Iterate over the messages stored in the cache for a specific channel.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> PARAMETER DESCRIPTION <code>channel_id</code> <p>The ID of the channel to iterate over the messages cached for them.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>CacheIterator[hikari.messages.Message]</code> <p>An async iterator of the messages stored in the cache for the specified channel.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.RefMessageCache.iter_messages_for_author","title":"iter_messages_for_author  <code>abstractmethod</code>","text":"<pre><code>iter_messages_for_author(user_id)\n</code></pre> <p>Iterate over the messages stored in the cache for a specific author.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> PARAMETER DESCRIPTION <code>user_id</code> <p>The ID of the user to iterate over the messages cached for them.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>CacheIterator[hikari.messages.Message]</code> <p>An async iterator of the messages stored in the cache for the specified user.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.RefMessageCache.iter_messages_for_guild","title":"iter_messages_for_guild  <code>abstractmethod</code>","text":"<pre><code>iter_messages_for_guild(guild_id)\n</code></pre> <p>Iterate over the messages stored in the cache for a specific guild.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to iterate over the messages cached for them.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>CacheIterator[hikari.messages.Message]</code> <p>An async iterator of the messages stored in the cache for the specified guild.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.RefPresenceCache","title":"RefPresenceCache","text":"<p>         Bases: <code>PresenceCache</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a referential presence cache.</p>"},{"location":"reference/abc/#sake.abc.RefPresenceCache.clear_presences_for_guild","title":"clear_presences_for_guild  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_presences_for_guild(guild_id)\n</code></pre> <p>Remove the presences cached for a specific guild.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to remove the cached presences for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.RefPresenceCache.clear_presences_for_user","title":"clear_presences_for_user  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_presences_for_user(user_id)\n</code></pre> <p>Remove the presences cached for a specific user.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> PARAMETER DESCRIPTION <code>user_id</code> <p>The ID of the user to remove the cached presences for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.RefPresenceCache.iter_presences_for_guild","title":"iter_presences_for_guild  <code>abstractmethod</code>","text":"<pre><code>iter_presences_for_guild(guild_id)\n</code></pre> <p>Iterate over the presences stored in the cache for a specific guild.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to iterate over the cached presences for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>CacheIterator[hikari.presences.MemberPresence]</code> <p>An async iterator of the presences stored in the cache for the specified guild.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.RefPresenceCache.iter_presences_for_user","title":"iter_presences_for_user  <code>abstractmethod</code>","text":"<pre><code>iter_presences_for_user(user_id)\n</code></pre> <p>Iterate over the presences stored in the cache for a specific user.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> PARAMETER DESCRIPTION <code>user_id</code> <p>The ID of the user to iterate over the cached presences for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>CacheIterator[hikari.presences.MemberPresence]</code> <p>An async iterator of the presences stored in the cache for the specified user.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.RefRoleCache","title":"RefRoleCache","text":"<p>         Bases: <code>RoleCache</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a referential role cache.</p>"},{"location":"reference/abc/#sake.abc.RefRoleCache.clear_roles_for_guild","title":"clear_roles_for_guild  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_roles_for_guild(guild_id)\n</code></pre> <p>Remove the roles cached for a specific guild.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to remove the cached roles for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.RefRoleCache.iter_roles_for_guild","title":"iter_roles_for_guild  <code>abstractmethod</code>","text":"<pre><code>iter_roles_for_guild(guild_id)\n</code></pre> <p>Iterate over the roles stored in the cache.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to get the roles cached for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>CacheIterator[hikari.guilds.Role]</code> <p>An async iterator of the roles stored in the cache for the specified guild.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.RefVoiceStateCache","title":"RefVoiceStateCache","text":"<p>         Bases: <code>VoiceStateCache</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a referential voice state cache.</p>"},{"location":"reference/abc/#sake.abc.RefVoiceStateCache.clear_voice_states_for_channel","title":"clear_voice_states_for_channel  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_voice_states_for_channel(channel_id)\n</code></pre> <p>Remove the voice states cached for a specified channel.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> PARAMETER DESCRIPTION <code>channel_id</code> <p>The ID of the channel to remove the voice states cached for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.RefVoiceStateCache.clear_voice_states_for_guild","title":"clear_voice_states_for_guild  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_voice_states_for_guild(guild_id)\n</code></pre> <p>Remove the voice states cached for a specified guild.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to remove the voice states cached for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.RefVoiceStateCache.iter_voice_states_for_channel","title":"iter_voice_states_for_channel  <code>abstractmethod</code>","text":"<pre><code>iter_voice_states_for_channel(channel_id)\n</code></pre> <p>Iterate over the voice states stored in the cache for a specific channel.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> PARAMETER DESCRIPTION <code>channel_id</code> <p>The ID of the channel to iterate over the voice states cached for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>CacheIterator[hikari.voices.VoiceState]</code> <p>An async iterator of the voice states stored in the cache for the specified channel.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.RefVoiceStateCache.iter_voice_states_for_guild","title":"iter_voice_states_for_guild  <code>abstractmethod</code>","text":"<pre><code>iter_voice_states_for_guild(guild_id)\n</code></pre> <p>Iterate over the voice states stored in the cache for a specific guild.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to iterate over the voice states cached for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>CacheIterator[hikari.voices.VoiceState]</code> <p>An async iterator of the voice states stored in the cache for the specified guild.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.Resource","title":"Resource","text":"<p>         Bases: <code>abc.ABC</code></p> <p>The basic interface which all cache resources should implement.</p>"},{"location":"reference/abc/#sake.abc.Resource.is_alive","title":"is_alive  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>is_alive: bool\n</code></pre> <p>Whether this client is alive.</p>"},{"location":"reference/abc/#sake.abc.Resource.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the resource(s) and allow them to disconnect from their relevant backend(s).</p> <p>Note</p> <p>This should pass without raising if called on an already closed resource.</p>"},{"location":"reference/abc/#sake.abc.Resource.open","title":"open  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>open()\n</code></pre> <p>Startup the resource(s) and allow them to connect to their relevant backend(s).</p> <p>Note</p> <p>This should pass without raising if called on an already opened resource.</p>"},{"location":"reference/abc/#sake.abc.RoleCache","title":"RoleCache","text":"<p>         Bases: <code>Resource</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a role cache.</p>"},{"location":"reference/abc/#sake.abc.RoleCache.clear_roles","title":"clear_roles  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_roles()\n</code></pre> <p>Empty the roles cache store.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.RoleCache.delete_role","title":"delete_role  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_role(role_id)\n</code></pre> <p>Remove a role from the cache.</p> <p>Note</p> <p>Delete methods do not raise sake.errors.EntryNotFound when the targeted entity doesn't exist.</p> PARAMETER DESCRIPTION <code>role_id</code> <p>The ID of the role to remove from the cache.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.RoleCache.get_role","title":"get_role  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_role(role_id)\n</code></pre> <p>Get a role from the cache.</p> PARAMETER DESCRIPTION <code>role_id</code> <p>The ID of the role to get from the cache.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>hikari.guilds.Role</code> <p>The object of the role fetched from the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.EntryNotFound</code> <p>Raised when the targeted entity wasn't found.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.RoleCache.iter_roles","title":"iter_roles  <code>abstractmethod</code>","text":"<pre><code>iter_roles()\n</code></pre> <p>Iterate over the roles stored in the cache.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> RETURNS DESCRIPTION <code>CacheIterator[hikari.guilds.Role]</code> <p>An async iterator of the roles stored in the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.UserCache","title":"UserCache","text":"<p>         Bases: <code>Resource</code>, <code>abc.ABC</code></p> <p>The traits of a cache implementation which supports a user cache.</p> <p>Note</p> <p>Unlike other resources, user doesn't have any events which directly update it and may only be updated through event listeners when resources which reference it are also included.</p>"},{"location":"reference/abc/#sake.abc.UserCache.clear_users","title":"clear_users  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_users()\n</code></pre> <p>Empty the users cache store.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.UserCache.delete_user","title":"delete_user  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_user(user_id)\n</code></pre> <p>Remove a user from the cache.</p> <p>Note</p> <p>Delete methods do not raise sake.errors.EntryNotFound when the targeted entity doesn't exist.</p> PARAMETER DESCRIPTION <code>user_id</code> <p>The ID of the user to remove from the cache.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.UserCache.get_user","title":"get_user  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_user(user_id)\n</code></pre> <p>Get a user from the cache.</p> PARAMETER DESCRIPTION <code>user_id</code> <p>The ID of the user to get from the cache.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>hikari.users.User</code> <p>The object of the user fetched from the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.EntryNotFound</code> <p>Raised when the targeted entity wasn't found.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.UserCache.iter_users","title":"iter_users  <code>abstractmethod</code>","text":"<pre><code>iter_users()\n</code></pre> <p>Iterate over the users stored in the cache.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> RETURNS DESCRIPTION <code>CacheIterator[hikari.users.User]</code> <p>An async iterator of the users stored in the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.VoiceStateCache","title":"VoiceStateCache","text":"<p>         Bases: <code>Resource</code>, <code>abc.ABC</code></p> <p>The traits of a implementation which supports a voice state cache.</p>"},{"location":"reference/abc/#sake.abc.VoiceStateCache.clear_voice_states","title":"clear_voice_states  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>clear_voice_states()\n</code></pre> <p>Empty the voice states cache store.</p> <p>Note</p> <p>There is no guarantee that this operation will be complete before the returned coroutine finishes.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this call failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.VoiceStateCache.delete_voice_state","title":"delete_voice_state  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_voice_state(guild_id, user_id)\n</code></pre> <p>Remove a voice state from the cache.</p> <p>Note</p> <p>Delete methods do not raise sake.errors.EntryNotFound when the targeted entity doesn't exist.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to remove a cached voice state for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> <code>user_id</code> <p>The ID of the user to remove a cached voice state for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p>"},{"location":"reference/abc/#sake.abc.VoiceStateCache.get_voice_state","title":"get_voice_state  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_voice_state(guild_id, user_id)\n</code></pre> <p>Get a voice state from the cache.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>The ID of the guild to get a cached voice state for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> <code>user_id</code> <p>The ID of the user to get a cached voice state for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>hikari.voices.VoiceState</code> <p>The object of the voice state fetched from the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.EntryNotFound</code> <p>Raised when the targeted entity wasn't found.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/abc/#sake.abc.VoiceStateCache.iter_voice_states","title":"iter_voice_states  <code>abstractmethod</code>","text":"<pre><code>iter_voice_states()\n</code></pre> <p>Iterate over the voice states stored in the cache.</p> <p>Note</p> <p>Errors won't be raised by the initial call to this method but rather while iterating over the returned asynchronous iterator.</p> RETURNS DESCRIPTION <code>CacheIterator[hikari.voices.VoiceState]</code> <p>An async iterator of the voice states stored in the cache.</p> RAISES DESCRIPTION <code>sake.errors.BackendError</code> <p>Raised when this failed to communicate with the cache's backend. This may be a sign of underlying network or database issues.</p> <code>sake.errors.InvalidDataFound</code> <p>Raised when the data retrieved from the backend datastore was either invalid for this implementation or corrupt. This may be a sign of multiple sake versions or implementations being used with the same backend store.</p>"},{"location":"reference/errors/","title":"sake.errors","text":"<p>The standard error bases which Sake implementations will be raising.</p> <p>Note</p> <p>These supplement python's builtin exceptions but do not replace them.</p>"},{"location":"reference/errors/#sake.errors.BackendError","title":"BackendError","text":"<p>         Bases: <code>SakeException</code>, <code>ValueError</code></p> <p>Error that's raised when communicating with the backend fails.</p> <p>This may be a sign of underlying network or database issues.</p>"},{"location":"reference/errors/#sake.errors.CannotDelete","title":"CannotDelete","text":"<p>         Bases: <code>SakeException</code>, <code>ValueError</code></p> <p>Error that's raised in response to an attempt to delete an entry which can't be deleted.</p> <p>This most likely reason for this to be raised would be due to an attempt to deleted a entry that's being kept alive by references without specifying to cascade references in a referential database.</p>"},{"location":"reference/errors/#sake.errors.ClosedClient","title":"ClosedClient","text":"<p>         Bases: <code>SakeException</code></p> <p>Error that's raised when an attempt to use an inactive client is made.</p>"},{"location":"reference/errors/#sake.errors.EntryNotFound","title":"EntryNotFound","text":"<p>         Bases: <code>SakeException</code>, <code>LookupError</code></p> <p>Error that's raised in response to an attempt to get an entry which doesn't exist.</p> <p>Note</p> <p>This shouldn't ever be raised by a delete method or iter method.</p>"},{"location":"reference/errors/#sake.errors.InvalidDataFound","title":"InvalidDataFound","text":"<p>         Bases: <code>SakeException</code>, <code>LookupError</code></p> <p>Error that's raised when the retrieved data is in an unexpected format.</p> <p>This may indicate that you are running different versions of a Sake implementation with the same database.</p>"},{"location":"reference/errors/#sake.errors.SakeException","title":"SakeException","text":"<p>         Bases: <code>Exception</code></p> <p>Base exception for the expected exceptions raised by Sake implementations.</p>"},{"location":"reference/errors/#sake.errors.SakeException.base","title":"base  <code>class-attribute</code>","text":"<pre><code>base: typing.Optional[Exception]\n</code></pre> <p>The exception which caused this exception if applicable else None.</p>"},{"location":"reference/errors/#sake.errors.SakeException.__init__","title":"__init__","text":"<pre><code>__init__(message, *, exception=None)\n</code></pre> <p>Initialise a sake exception instance.</p> PARAMETER DESCRIPTION <code>message</code> <p>The exception's message.</p> <p> TYPE: <code>str</code> </p> <code>exception</code> <p>The exception which caused this exception if applicable else None.</p> <p> TYPE: <code>typing.Optional[Exception]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/redis/","title":"sake.redis","text":"<p>Redis based implementations of Sake's clients.</p>"},{"location":"reference/redis/#sake.redis.DEFAULT_EXPIRE","title":"DEFAULT_EXPIRE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_EXPIRE: typing.Final[int] = 3600000\n</code></pre> <p>The default expire time (in milliseconds) used for expiring resources of 60 minutes.</p>"},{"location":"reference/redis/#sake.redis.DEFAULT_FAST_EXPIRE","title":"DEFAULT_FAST_EXPIRE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_FAST_EXPIRE: typing.Final[int] = 300000\n</code></pre> <p>The default expire time (in milliseconds) used for expiring resources quickly of 5 minutes.</p>"},{"location":"reference/redis/#sake.redis.DEFAULT_INVITE_EXPIRE","title":"DEFAULT_INVITE_EXPIRE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_INVITE_EXPIRE: typing.Final[int] = 2592000000\n</code></pre> <p>A special case month long default expire time for invite entries without a set \"expire_at\".</p>"},{"location":"reference/redis/#sake.redis.DEFAULT_SLOW_EXPIRE","title":"DEFAULT_SLOW_EXPIRE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_SLOW_EXPIRE: typing.Final[int] = 604800\n</code></pre> <p>The default expire time (in milliseconds) used for gateway-event deleted resources (1 week).</p>"},{"location":"reference/redis/#sake.redis.EmojiCache","title":"EmojiCache","text":"<p>         Bases: <code>_Reference</code>, <code>sake_abc.RefEmojiCache</code></p> <p>Redis implementation of sake.abc.EmojiCache.</p>"},{"location":"reference/redis/#sake.redis.GuildCache","title":"GuildCache","text":"<p>         Bases: <code>ResourceClient</code>, <code>sake_abc.GuildCache</code></p> <p>Redis implementation of sake.abc.GuildCache.</p>"},{"location":"reference/redis/#sake.redis.GuildChannelCache","title":"GuildChannelCache","text":"<p>         Bases: <code>_Reference</code>, <code>sake_abc.RefGuildChannelCache</code></p> <p>Redis implementation of sake.abc.RefGuildChannelCache.</p>"},{"location":"reference/redis/#sake.redis.InviteCache","title":"InviteCache","text":"<p>         Bases: <code>ResourceClient</code>, <code>sake_abc.InviteCache</code></p> <p>Redis implementation of sake.abc.InviteCache.</p>"},{"location":"reference/redis/#sake.redis.InviteCache.with_invite_expire","title":"with_invite_expire","text":"<pre><code>with_invite_expire(expire)\n</code></pre> <p>Set the default expire time for invite entries added with this client.</p> PARAMETER DESCRIPTION <code>expire</code> <p>The default expire time to add for invites in this cache or None to set back to the default behaviour. This may either be the number of seconds as an int or float (where millisecond precision is supported) or a timedelta.</p> <p> TYPE: <code>typing.Optional[_internal.ExpireT]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client this is being called on to enable chained calls.</p>"},{"location":"reference/redis/#sake.redis.MemberCache","title":"MemberCache","text":"<p>         Bases: <code>ResourceClient</code>, <code>sake_abc.MemberCache</code></p> <p>Redis implementation of sake.abc.MemberCache.</p>"},{"location":"reference/redis/#sake.redis.MessageCache","title":"MessageCache","text":"<p>         Bases: <code>ResourceClient</code>, <code>sake_abc.MessageCache</code></p> <p>Redis implementation of sake.abc.MessageCache.</p>"},{"location":"reference/redis/#sake.redis.MessageCache.with_message_expire","title":"with_message_expire","text":"<pre><code>with_message_expire(expire)\n</code></pre> <p>Set the default expire time for message entries added with this client.</p> PARAMETER DESCRIPTION <code>expire</code> <p>The default expire time to add for messages in this cache or None to set back to the default behaviour. This may either be the number of seconds as an int or float (where millisecond precision is supported) or a timedelta.</p> <p> TYPE: <code>typing.Optional[_internal.ExpireT]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client this is being called on to enable chained calls.</p>"},{"location":"reference/redis/#sake.redis.PresenceCache","title":"PresenceCache","text":"<p>         Bases: <code>ResourceClient</code>, <code>sake_abc.PresenceCache</code></p> <p>Redis implementation of sake.abc.PresenceCache.</p>"},{"location":"reference/redis/#sake.redis.RedisCache","title":"RedisCache","text":"<p>         Bases: <code>GuildCache</code>, <code>EmojiCache</code>, <code>GuildChannelCache</code>, <code>InviteCache</code>, <code>MemberCache</code>, <code>MessageCache</code>, <code>PresenceCache</code>, <code>RoleCache</code>, <code>UserCache</code>, <code>VoiceStateCache</code>, <code>sake_abc.Cache</code></p> <p>A Redis implementation of all the defined cache resources.</p>"},{"location":"reference/redis/#sake.redis.ResourceClient","title":"ResourceClient","text":"<p>         Bases: <code>sake_abc.Resource</code>, <code>abc.ABC</code></p> <p>A base client which all resources in this implementation will implement.</p> <p>Note</p> <p>This cannot be initialised by itself and is useless alone.</p>"},{"location":"reference/redis/#sake.redis.ResourceClient.app","title":"app  <code>property</code>","text":"<pre><code>app: hikari.RESTAware\n</code></pre> <p>The Hikari client this resource client is tied to.</p> <p>This is used to build models with a <code>app</code> attribute.</p>"},{"location":"reference/redis/#sake.redis.ResourceClient.config","title":"config  <code>property</code>","text":"<pre><code>config: collections.MutableMapping[str, typing.Any]\n</code></pre> <p>This client's settings.</p>"},{"location":"reference/redis/#sake.redis.ResourceClient.default_expire","title":"default_expire  <code>property</code>","text":"<pre><code>default_expire: typing.Optional[int]\n</code></pre> <p>The default expire time used for fields with no actual lifetime.</p> <p>If this is None then these cases will have no set expire after.</p>"},{"location":"reference/redis/#sake.redis.ResourceClient.event_manager","title":"event_manager  <code>property</code>","text":"<pre><code>event_manager: typing.Optional[hikari.api.EventManager]\n</code></pre> <p>The event manager this resource client is using for managing state.</p>"},{"location":"reference/redis/#sake.redis.ResourceClient.__init__","title":"__init__","text":"<pre><code>__init__(address, app, event_manager=None, *, config=None, default_expire=DEFAULT_SLOW_EXPIRE, event_managed=False, password=None, max_connections_per_db=5, dumps=lambda obj: json.dumps(obj).encode(), loads=json.loads)\n</code></pre> <p>Initialise a resource client.</p> PARAMETER DESCRIPTION <code>app</code> <p>The Hikari client all the models returned by this client should be bound to.</p> <p> TYPE: <code>hikari.RESTAware</code> </p> <code>address</code> <p>The address to use to connect to the Redis backend server this resource is linked to.</p> <p>E.g: - <code>\"redis://[[username]:[password]]@localhost:6379\"</code> - <code>\"rediss://[[username]:[password]]@localhost:6379\"</code> - <code>\"unix://[[username]:[password]]@/path/to/socket.sock\"</code></p> <p>Three URL schemes are supported: - <code>redis://</code>: creates a TCP socket connection. See more at: https://www.iana.org/assignments/uri-schemes/prov/redis - <code>rediss://</code>: creates a SSL wrapped TCP socket connection. See more at: https://www.iana.org/assignments/uri-schemes/prov/rediss - <code>unix://</code>: creates a Unix Domain Socket connection.</p> <p> TYPE: <code>str</code> </p> <code>event_manager</code> <p>The event manager to bind this resource client to.</p> <p>If provided then this client will automatically manage resources based on received gateway events.</p> <p> TYPE: <code>typing.Optional[hikari.api.EventManager]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether the client should be started and stopped based on the attached event_manager's lifetime events.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>password</code> <p>The password to use to connect to the backend Redis server.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>When <code>event_managed</code> is True and <code>event_manager</code> wasn't passed.</p>"},{"location":"reference/redis/#sake.redis.ResourceClient.add_to_tanjun","title":"add_to_tanjun","text":"<pre><code>add_to_tanjun(client, /, *, trust_get_for=None, tanjun_managed=False)\n</code></pre> <p>Add this Redis client to a Tanjun client.</p> <p>This method will register type dependencies for the resources implemented by it (including tanjun.dependencies.async_cache compatible adapters which will allow Tanjun extensions and standard utility such as converters to be aware of this cache).</p> <p>The type dependencies this will register depend on which resources are implemented but are as follows for each standard resource implementation:</p> <ul> <li>sake.redis.EmojiCache<ul> <li>sake.abc.EmojiCache</li> <li>sake.abc.RefEmojiCache</li> <li>sake.redis.EmojiCache</li> <li><code>tanjun.dependencies.async_cache.SfCache[hikari.KnownCustomEmoji]</code></li> <li><code>tanjun.dependencies.async_cache.SfGuildBound[hikari.KnownCustomEmoji]</code></li> </ul> </li> <li>sake.redis.GuildCache<ul> <li>sake.abc.GuildCache</li> <li>sake.redis.GuildCache</li> <li><code>tanjun.dependencies.async_cache.SfCache[hikari.Guild]</code></li> <li><code>tanjun.depepdencies.async_cache.SfCache[hikari.GatewayGuild]</code></li> </ul> </li> <li>sake.redis.GuildChannelCache<ul> <li>sake.abc.GuildChannelCache</li> <li>sake.abc.RefGuildChannelCache</li> <li>sake.redis.GuildChannelCache</li> <li><code>tanjun.dependencies.async_cache.SfCache[hikari.PermissibleGuildChannel]</code></li> <li><code>tanjun.dependencies.async_cache.SfGuildBound[hikari.PermissibleGuildChannel]</code></li> </ul> </li> <li>sake.redis.InviteCache<ul> <li>sake.abc.InviteCache</li> <li>sake.redis.InviteCache</li> <li><code>tanjun.dependencies.async_cache.SfCache[hikari.Invite]</code></li> <li><code>tanjun.dependencies.async_cache.SfCache[hikari.InviteWithMetadata]</code></li> </ul> </li> <li>sake.redis.MemberCache<ul> <li>sake.abc.MemberCache</li> <li>sake.redis.MemberCache</li> <li><code>tanjun.dependencies.async_cache.SfGuildBound[hikari.Member]</code></li> </ul> </li> <li>sake.redis.MessageCache<ul> <li>sake.abc.MessageCache</li> <li>sake.redis.MessageCache</li> <li><code>tanjun.dependencies.async_cache.SfCache[hikari.Message]</code></li> </ul> </li> <li>sake.redis.PresenceCache<ul> <li>sake.abc.PresenceCache</li> <li>sake.redis.PresenceCache</li> <li><code>tanjun.dependencies.async_cache.SfGuildBound[hikari.MemberPresence]</code></li> </ul> </li> <li>sake.redis.RoleCache<ul> <li>sake.abc.RoleCache</li> <li>sake.redis.RoleCache</li> <li><code>tanjun.dependencies.async_cache.SfCache[hikari.Role]</code></li> <li><code>tanjun.dependencies.async_cache.SfGuildBound[hikari.Role]</code></li> </ul> </li> <li>sake.redis.UserCache<ul> <li>sake.abc.MeCache</li> <li>sake.abc.UserCache</li> <li>sake.redis.UserCache</li> <li><code>tanjun.dependencies.async_cache.SingleStoreCache[hikari.OwnUser]</code></li> <li><code>tanjun.dependencies.async_cache.SfCache[hikari.User]</code></li> </ul> </li> <li>sake.redis.VoiceStateCache<ul> <li>sake.abc.VoiceStateCache</li> <li>sake.redis.VoiceStateCache</li> <li><code>tanjun.dependencies.async_cache.SfGuildBound[hikari.VoiceState]</code></li> </ul> </li> <li>sake.redis.RedisCache<ul> <li>All of the previously listed types</li> <li>sake.abc.Cache</li> <li>sake.redis.RedisCache</li> </ul> </li> </ul> PARAMETER DESCRIPTION <code>client</code> <p>The Tanjun client to add this client to.</p> <p> TYPE: <code>tanjun.abc.Client</code> </p> <code>trust_get_for</code> <p>A collection of resource types which the tanjun.dependencies.async_cache adapter \"get\" methods should raise tanjun.dependencies.async_cache.EntryNotFound if the entry isn't found rather than just tanjun.dependencies.async_cache.CacheMissError.</p> <p>If not passed then this will default to the following resources:</p> <ul> <li>sake.abc.EmojiCache</li> <li>sake.abc.GuildCache</li> <li>sake.abc.GuildChannelCache</li> <li>sake.abc.MemberCache</li> <li>sake.abc.PresenceCache</li> <li>sake.abc.RoleCache</li> <li>sake.abc.VoiceStateCache</li> <li>sake.abc.UserCache (if sake.abc.MemberCache is also implemented).</li> </ul> <p> TYPE: <code>typing.Optional[collections.Collection[type[sake_abc.Resource]]]</code> DEFAULT: <code>None</code> </p> <code>tanjun_managed</code> <p>Whether the client should be started and stopped based on the tanjun client's lifecycle.</p> <p>This is useful if the client isn't being event managed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If this is called in an environment without Tanjun.</p>"},{"location":"reference/redis/#sake.redis.ResourceClient.all_indexes","title":"all_indexes","text":"<pre><code>all_indexes()\n</code></pre> <p>Get a set of all the Redis client indexes this is using.</p> <p>Note</p> <p>This accounts for index overrides.</p> RETURNS DESCRIPTION <code>collections.abc.MutableSet[ResourceIndex | int]</code> <p>A set of all the Redis client indexes this is using.</p>"},{"location":"reference/redis/#sake.redis.ResourceClient.all_intents","title":"all_intents  <code>classmethod</code>","text":"<pre><code>all_intents()\n</code></pre> <p>The intents required for a client to be sufficient event managed.</p> <p>If not all these intents are present in the linked event manager then this client won't be able to reliably fill and manage the linked redis database(s).</p>"},{"location":"reference/redis/#sake.redis.ResourceClient.dump","title":"dump","text":"<pre><code>dump(data)\n</code></pre> <p>Serialize a dict object representation into the form to be stored.</p> PARAMETER DESCRIPTION <code>data</code> <p>The dict object to serialize.</p> <p> TYPE: <code>_ObjectT</code> </p> RETURNS DESCRIPTION <code>bytes</code> <p>The object serialized as bytes.</p>"},{"location":"reference/redis/#sake.redis.ResourceClient.get_index_override","title":"get_index_override","text":"<pre><code>get_index_override(index)\n</code></pre> <p>Get the override set for an index.</p> PARAMETER DESCRIPTION <code>index</code> <p>The index to get the override for.</p> <p> TYPE: <code>ResourceIndex</code> </p> RETURNS DESCRIPTION <code>int | None</code> <p>The found override if set, else None.</p>"},{"location":"reference/redis/#sake.redis.ResourceClient.index","title":"index  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>index()\n</code></pre> <p>The index for the resource which this class is linked to.</p> <p>Note</p> <p>This should be called on specific base classes and will not be accurate after inheritance.</p> <p>Warning</p> <p>This doesn't account for overrides.</p> RETURNS DESCRIPTION <code>collections.abc.Sequence[ResourceIndex]</code> <p>The index of the resource this class is linked to.</p>"},{"location":"reference/redis/#sake.redis.ResourceClient.intents","title":"intents  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>intents()\n</code></pre> <p>The intents the resource requires to function properly.</p> <p>Note</p> <p>This should be called on specific base classes and will not be accurate after inheritance.</p> RETURNS DESCRIPTION <code>hikari.intents.Intents</code> <p>The intents the resource requires to function properly.</p>"},{"location":"reference/redis/#sake.redis.ResourceClient.load","title":"load","text":"<pre><code>load(data)\n</code></pre> <p>Deserialize a bytes representation to a dict object.</p> PARAMETER DESCRIPTION <code>data</code> <p>The bytes representation from the database to a dict object.</p> <p> TYPE: <code>bytes</code> </p> RETURNS DESCRIPTION <code>dict[str, typing.Any]</code> <p>The deserialized dict object.</p>"},{"location":"reference/redis/#sake.redis.ResourceClient.with_index_override","title":"with_index_override","text":"<pre><code>with_index_override(index, /, *, override=None)\n</code></pre> <p>Add an index override.</p> PARAMETER DESCRIPTION <code>index</code> <p>The index to override.</p> <p> TYPE: <code>ResourceIndex</code> </p> <code>override</code> <p>The override to set.</p> <p>If this is left at None then any previous override is unset. This will decide which Redis database is targeted for a resource.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/redis/#sake.redis.ResourceIndex","title":"ResourceIndex","text":"<p>         Bases: <code>enum.IntEnum</code></p> <p>An enum of the indexes used to map cache resources to their redis databases.</p>"},{"location":"reference/redis/#sake.redis.RoleCache","title":"RoleCache","text":"<p>         Bases: <code>_Reference</code>, <code>sake_abc.RoleCache</code></p> <p>Redis implementation of sake.abc.RoleCache.</p>"},{"location":"reference/redis/#sake.redis.UserCache","title":"UserCache","text":"<p>         Bases: <code>_MeCache</code>, <code>sake_abc.UserCache</code></p> <p>Redis implementation of sake.abc.UserCache.</p>"},{"location":"reference/redis/#sake.redis.UserCache.with_user_expire","title":"with_user_expire","text":"<pre><code>with_user_expire(expire)\n</code></pre> <p>Set the default expire time for user entries added with this client.</p> PARAMETER DESCRIPTION <code>expire</code> <p>The default expire time to add for users in this cache or None to set back to the default behaviour. This may either be the number of seconds as an int or float (where millisecond precision is supported) or a timedelta.</p> <p> TYPE: <code>typing.Optional[_internal.ExpireT]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client this is being called on to enable chained calls.</p>"},{"location":"reference/redis/#sake.redis.VoiceStateCache","title":"VoiceStateCache","text":"<p>         Bases: <code>_Reference</code>, <code>sake_abc.VoiceStateCache</code></p> <p>Redis implementation of sake.abc.VoiceStateCache.</p>"}]}